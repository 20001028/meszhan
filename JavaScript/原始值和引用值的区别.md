# 原始值和引用值的区别

https://juejin.cn/post/6844903557968166926#heading-5

### 引言

> + 存储位置
> + 值的拷贝
> + 值的比较

### 基本类型

+ String
+ Number
+ Boolean
+ Symbol
+ undefined
+ null
+ Bigint

### 引用类型

+ Object
+ Array
+ Function
+ RegExp
+ Date
+ 等等

### 存储位置

> 联想到堆和栈的区别，联想数组是如何存储的

### 值的拷贝

> 联想到深拷贝和浅拷贝

### 值的比较

> 适当联想到==中到隐式转换，==和===的区别

### 隐式转换

> + ToPrimitive
>
> + ToNumber
> + ToString

#### ToPrimitive

> 将值转为原始值
>
> ToPrimitive((input,PerferredType))
>
> + Input：要转换的值
> + PerferredType：可选参数，Number/String
>
> 转换后的结果不一定是这个参数所指的类型，但是一定是原始值或报错
>
> + 如果PerferredType标记为Number
>
>   + 如果input是原始值，直接返回
>
>   + 如果输入是对象，调用valueOf方法
>
>     如果valueOf方法的返回值是一个原始值返回原始值
>
>   + 否则，调用toString方法，如果是原始值，返回原始值
>
>   + 抛出异常
>
> + 如果PreferredType标记为String
>
>   + 如果是原始值，直接返回原始值
>   + 调用toString方法，如果toString方法返回原始值，返回这个原始值
>   + 如果是一个对象，调用valueOf方法，valueOf方法返回值，返回这个原始值
>   + 抛出异常
>
> + 如果没有PreferredType参数
>
>   + 该对象为Date类型，设置为String
>   + 否则，设置为Number

#### valueOf方法和toString方法

> valueof方法和toString方法在对象内部一定存在，在Object.prototype中输出就可以看到

**Number、Boolean、String**：valueOf转换为相应的原始值

```javascript
var num = new Number('123');
num.valueOf(); // 123

var str = new String('12df');
str.valueOf(); // '12df'

var bool = new Boolean('fd');
bool.valueOf(); // true
```

**Date**：日期转换为日期的毫秒形式的数值

```javascript
var a = new Date();
a.valueOf(); // 1515143895500
```

**返回this**

```javascript
var a = new Array();
a.valueOf() === a; // true

var b = new Object({});
b.valueOf() === b; // true
```

### ==运算符隐式转换

> 比较运算x==y，若x和y是值，返回true或false
>
> + x和y为null、undefined两者一个，返回true
> + x、y为Number或String类型时，转换为Number类型比较
> + 有Boolean类型，Boolean转换为Number类型
> + 有Object类型，将Object原始转换后比较

#### 例子

```javascript
var a = {
    valueOf: function () {
        return 1;
    },
    toString: function () {
        return '123'
    }
}
console.log(1 == true); //true

/*
	* 首先!{}为false，ToNumber转换得到0
	* 然后[]调用ToPrimitive，调用toString得到''
	* 最后ToNumber('')转换为0
	* 得到true
*/
console.log([] == !{}); //true

const a = {
    i: 1,
    toString: function () {
        return a.i++;
    }
}
/*
	* 首先a是对象，会先调用ToPrimitive转换为Number，先调valueOf方法，但因为返回的是自身而不是原始类型因此调用toString方法
	* 第一次比较返回1，得到true
	* 第二次比较返回2，得到true
	* 第三次比较返回3，得到true
	* 进入条件语句块
*/
if (a == 1 && a == 2 && a == 3) {
    console.log('hello world!');
}
```

#### ToNumber将值转换为数字

+ undefined	NaN
+ null +0
+ 布尔值：true转换1，false转换为0
+ 字符串：字符串解析为数字
+ 对象obj：调用ToPrimitive((obj,Number))得到原始值，再进行ToNumber转换为数字

#### ToString将值转换为字符串

+ undefined：‘undefined’
+ null：‘null’
+ 布尔值：‘true’或‘false’
+ 数字：
+ 对象：先调用ToPrimitive(obj,String)得到原始值，再toString转换为字符串

```javascript
({} + {}) = ?
两个对象的值进行+运算符，肯定要先进行隐式转换为原始类型才能进行计算。
1、进行ToPrimitive转换，由于没有指定PreferredType类型，{}会使默认值为Number，进行ToPrimitive(input, Number)运算。
2、所以会执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。
3、继续执行toString方法，({}).toString(),返回"[object Object]"，是原始值。
故得到最终的结果，"[object Object]" + "[object Object]" = "[object Object][object Object]"

2 * {} = ?
1、首先*运算符只能对number类型进行运算，故第一步就是对{}进行ToNumber类型转换。
2、由于{}是对象类型，故先进行原始类型转换，ToPrimitive(input, Number)运算。
3、所以会执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。
4、继续执行toString方法，({}).toString(),返回"[object Object]"，是原始值。
5、转换为原始值后再进行ToNumber运算，"[object Object]"就转换为NaN。
故最终的结果为 2 * NaN = NaN
```

### 区别

> + 对于基本类型来说，复制变量复制的是变量的值，与原来的变量并无关系；对于引用类型，复制变量只是复制引用地址而已，两者除了在栈中的地址不同之外，但指向的对象是同一个，因此修改会相互影响
> + 因为引用数据占据的空间会比较大且不固定，因此存储在堆内存中不会影响程序性能，但是引用数据的内存地址依然存储在栈中；基本类型的数据因为大小固定，存储在栈中































































