# 浮点数精度丢失问题

### 引出问题

```javascript
console.log(0.1+0.2);
> 0.30000000000000004
```

### Number类型

> 回顾一下Js中的七大基本类型：Number、String、Boolean、undefined、null、Symblo、Bigint
>
> 可以看到js中的数字类型只有Number类型，也就是其他类似Java中的double双精度浮点型，不区分浮点型和整数型
>
> Number的四种进制表示法：二进制、十进制、八进制、十六进制
>
> Number类型使用IEEE754格式表示整数和浮点值

+ 二进制：0B或0b，后接1或0表示二进制数
+ 十进制数：默认0-9

### IEEE754

> 64位二进制表示一个数字，64位=1位符号位+11位指数位+52位小数位
>
> + 符号位：表示正负，0为正，1为负，-1^0=1，-1^1=-1
> + 指数位：用科学计数法表示数值大小一般都是二进制的，表示2^n
> + 小数位：科学计数法前面的值，默认所有数值都转为1.xxxx格式，可以省略一位小数位，存储更多数字内容，但是会丢失精度

### 精度丢失

> 本质：将浮点数转换为IEEE754标准的二进制过程中出现丢失
>
> 小数转换为二进制：乘二取整法

```
0.1*2=0.2======取出整数部分0

0.2*2=0.4======取出整数部分0

0.4*2=0.8======取出整数部分0

0.8*2=1.6======取出整数部分1

0.6*2=1.2======取出整数部分1

0.2*2=0.4======取出整数部分0

0.4*2=0.8======取出整数部分0

0.8*2=1.6======取出整数部分1

0.6*2=1.2======取出整数部分1

接下来会无限循环

0.2*2=0.4======取出整数部分0

0.4*2=0.8======取出整数部分0

0.8*2=1.6======取出整数部分1

0.6*2=1.2======取出整数部分1

所以0.1转化成二进制是：0.0001 1001 1001 1001…（无限循环）

0.1 => 0.0001 1001 1001 1001…（无限循环）
```

### 解决方法

+ 考虑到每次浮点数运算的偏差较小，可以对结果进行指定精度的四舍五入

  ```
  parseFloat(result.toFixed(12));
  ```

+ 将浮点数转为整数运算，再做除法

+ 将浮点数转为字符串，模拟实际运算过程























