# 计算机网络

### 深入HTTPS

#### SSL握手过程

在开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手

+ 首先，客户端会给出支持的协议版本号、客户端生成的随机数，以及客户端支持的加密方法
+ 服务端确认双方的加密方法后，给出自己的数字证书，以及服务端生成的一个随机数
+ 客户端在确认证书有效后，生成一个新的随机数，并用数字证书中的公钥加密这个随机数，发给服务端
+ 服务端使用自己的私钥解密第三个随机数
+ 客户端和服务端根据约定的加密方法，使用前面交换的三个随机数，生成一个对话密钥（session key），加密接下来的整个对话过程

![](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092004.png)

#### 私钥的作用

+ 生成对话密钥一共需要三个随机数
+ 握手之后的对话使用对话密钥进行加密，也就是对称加密，服务器的公钥和私钥只用于加密和解密对话密钥（非对称加密），没有其他作用
+ 服务器的公钥存放在服务器的数字证书中

整个对话过程中给你，服务器的公钥和私钥只需要用到一次

#### DH算法的握手阶段

毫无疑问，整个握手阶段都不会进行加密，都是明文传输。因此，如果有人窃听通信，就可以知道双方选择的加密方法，以及三个随机数中的两个，整个通话的安全只取决于第三个随机数是否会被破解。

虽然理论上只要服务器的公钥足够长，那么第三个随机数就可以保证不被破解。但是为了足够安全，可以考虑把握手阶段的算法从默认的RSA算法改为DH算法。

采用DH算法后iu，第三个参数Premaster secret不需要传递，只要交换各自的参数就可以算出随机数。

<img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092008.png" style="zoom:200%;" />

#### session的恢复

握手阶段用来建立SSL连接，如果出于某种原因对话中断了，就需要重新握手

有两种方法可以恢复原来的session：

+ session ID
+ session ticket

session的思想很简单，就是每一次对话都有一个编号session ID，如果对话中断，下次重连时，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的对话密钥，不需要重新协商。

![](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092010.png)

##### 缺点

session ID是目前所有浏览器支持的方法，但是缺点在于session ID只保留在一台服务器上。所以如果客户端的请求发到另一个服务器，

就无法恢复对话，所以有了session ticket。

![](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092012.png)

在上面，客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密后的，只有服务器才能解密，其中包括了本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket后，揭秘后就不必重新生成对话密钥了。

### HTTP系列全集（1.0、1.1、2.0、3.0）

### HTTP（状态码、请求头、请求方法）

### Websocket

https://juejin.cn/post/6844903544978407431#heading-13

WebSocket最大的意义的就是让浏览器可以实时的双向通信，因为我们知道的所有HTTP协议（1.0，1.1，2.0乃至是3）都只能通过请求响应式应答，无法脱离请求主动发出消息

主要介绍：

+ WebSocket如何建立连接
+ 如何交换数据
+ 数据帧的格式
+ 针对WebSocket的安全攻击
+ WebScket如何抵御攻击

#### 什么是WebSocket

HTML5提供的一种浏览器与服务器进行全双工通信的网络技术，应用层协议（同HTTP），与HTTP3之前的协议一样，它基于TCP并复用了HTTP的握手通道

#### 优点

+ 支持双向通信

+ 更好的二进制支持

+ 较少的控制开销

  创建连接时，ws客户端和服务端数据交换时协议控制的数据包头部较小。不包含头部时，服务端到客户端的包头只有2-10字节（取决于数据包长度），客户端到服务端，需要加上额外的4字节掩码，而HTTP协议每次通信都需要携带完整的头部

+ 支持扩展

  ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议

#### 学习什么

+ 如何建立连接
+ 如何交换数据
+ 数据帧格式
+ 如何维持连接

#### 入门例子

##### 服务端

它监听了8080端口，当有新的连接请求到达时，打印日志，并向客户端发送消息

当收到来自客户端消息时，同样打印日志

```javascript
var app = require('express')();
var server = require('http').Server(app);
var WebSocket = require('ws');

var wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', function connection(ws) {
    console.log('server: receive connection.');
    
    ws.on('message', function incoming(message) {
        console.log('server: received: %s', message);
    });

    ws.send('world');
});

app.get('/', function (req, res) {
  res.sendfile(__dirname + '/index.html');
});

app.listen(3000);
```

##### 客户端

向8080端口发起WebSocket连接，连接建立后，打印日志，同时发送消息给服务端

接收到来自服务端的消息后，同样打印日志

```html
<script>
  var ws = new WebSocket('ws://localhost:8080');
  ws.onopen = function () {
    console.log('ws onopen');
    ws.send('from client: hello');
  };
  ws.onmessage = function (e) {
    console.log('ws onmessage');
    console.log('from server: ' + e.data);
  };
</script>
```

#### 如何建立连接

WebSocket复用了HTTP的握手通道，客户端通过HTTP请求与WebSocket服务端协商升级协议

协议升级完成后，后续的数据交换都通过WebSocket协议

##### 客户端申请协议升级

客户端发起协议升级请求，采用标准的HTTP报文格式，只支持GET方法

下面只是一些重点的请求头部，因为是标准的HTTP请求，类似Host、Origin、Cookie等请求头都会发送

```http
GET / HTTP/1.1
Host: localhost:8080
Origin: http://127.0.0.1:3000
// 表示要升级协议
Connection: Upgrade
// 要升级到websocket协议
Upgrade: websocket
// websocket版本，如果服务端不支持，应返回Sec-WebSocket-Version的header，包含服务端支持的版本号
Sec-WebSocket-Version: 13
// 与后面服务端响应首部的Sec-WebSocket-Accept配套，提供基本的防护，防止恶意的连接或无意的连接
Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==
```

##### 服务端响应协议升级

状态101表示1协议切换，到此完成协议升级，后续的数据交互按照新的协议来

```http
HTTP/1.1 101 Switching Protocols
Connection:Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=
```

##### Sec-WebSocket_Accept的计算

Sec-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来

计算公式：

+ 将Sec-WebSocket-Key与258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接
+ 通过SHA1计算出摘要，并转成base64字符串

```javascript
const crypto = require('crypto');
const magic = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
const secWebSocketKey = 'w4v7O6xFTi36lq3RNcgctw==';

let secWebSocketAccept = crypto.createHash('sha1')
	.update(secWebSocketKey + magic)
	.digest('base64');

console.log(secWebSocketAccept);
// Oy4NRAQ13jhfONC7bP8dTKb4PTU=
```

#### 数据帧格式

客户端、服务端数据的交换，离不开数据帧格式的定义，因此我们需要了解一些WebSocket的数据帧格式

WebSocket客户端、服务端通信的最小单位是帧frame，由1个或多个帧组成一条完整message

+ 发送端：将消息切割成多个帧，并发送给服务端
+ 接受端：接受消息帧，并将关联的帧重新组装成完整的message

##### 格式概览

从左到右，单位是bit，比如FIN、RSV1/2/3各占据1bit，opcode占据4bit

内容包括标识位、操作代码opcode、掩码mask、数据、数据长度

```
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
```

##### 数据帧格式详解

+ FIN：1bit，可以参考TCP，如果FIN位是1，表示这是message的最后一个fragment，如果是0表示还有其他分片

+ RSV1/2/3：1bit，一般全为0，当客户端、服务端协商采用WebSocket扩展时，三个标志位可以非0，且值的含义由扩展定义

  如果出现非0值，且没有采用WebSocket扩展，连接出错

+ Opcode：4bit，操作代码，决定了应该如何解析后续的数据载何（Data Payload）

+ Mask：1bit，表示是否要对数据载荷进行掩码操作，从客户端向服务端发送数据时，需要对开数据进行掩码擦欧总；从服务端向客户端发送数据时，不需要进行掩码操作

  如果服务端收到了没有过掩码操作的数据，需要断开连接

+ Payload length：数据载荷长度，7bit或7+16bit或1+64bit，不包括Masking-key的长度

+ Masking-key：0或4bit，从客户端传输到服务端的数据帧，数据载荷都要掩码操作，Mask为1，会携带Masking-key，为0则没有

+ Payload data：x+y bit，扩展数据x bit+应用数据y bit

##### 掩码算法

- original-octet-i：为原始数据的第i字节。
- transformed-octet-i：为转换后的数据的第i字节。
- j：为`i mod 4`的结果。
- masking-key-octet-j：为mask key第j字节。

```
j = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j
```

#### 数据传递

一旦建立连接，后续的操作都是基于数据帧的传递

WebSocket根据opcode区分操作的类型，比如0x8表示断开连接，0x0-0x2表示数据交互

##### 数据分片

WebSocket的每条message都会被切分成多个frame，当接收方收到一个frame时，会根据FIN值判断是否为最后一个frame

FIN1表示最后一个frame，可以处理完整的消息，FIN0表示需要继续监听接受剩余的数据帧

opcode在数据交换场景下，表示数据类型

+ 0x08表示文本
+ 0x02表示二进制
+ 0x00表示延续帧，完整消息对应的数据帧还未接受完

##### 数据分片例子

```
Client: FIN=1, opcode=0x1, msg="hello"
Server: (process complete message immediately) Hi.
Client: FIN=0, opcode=0x1, msg="and a"
Server: (listening, new message containing text started)
Client: FIN=0, opcode=0x0, msg="happy new"
Server: (listening, payload concatenated to previous message)
Client: FIN=1, opcode=0x0, msg="year!"
Server: (process complete message) Happy new year to you too!
```

#### 连接保持+心跳

WebSocket为了保持客户端、服务端的实时双向痛惜你，需要确保客户端和服务端的TCP通道保持连接没有断开

但是，如果长时间没有数据往来，保持着会浪费包括的连接资源

采用心跳保持客户端与服务端的长时间连接

+ 发送方给接收方：ping

+ 接收方给发送方：pong

ping和pong对应WebSocket的两个控制帧，opcode对应0x9和0xA

```javascript
// WebSocket服务端向客户单发送pingws.ping('', false, true);
```

#### Sec-WebSocket-Key/Accept的作用

> 提供基础的防护，避免恶意连接和意外连接

+ 避免服务端收到非法的websocket连接，http客户端不小心连接到websocket服务
+ 确保服务端立即ws连接，因为ws在握手阶段仍然采用http协议，因此ws连接可能会被http服务器处理返回，这个头部可以避免，但不能预防无聊的http服务器故意处理这个头部但不实现ws协议
+ 发起ajax请求时，设置header时，ws有关的头部会被禁止携带，防止不需要的请求升级
+ 防止反向代理返回错误的数据，比如反向代理前后收到两次ws连接的升级请求，把第一次请求的返回cache，第二次直接返回（会出现脏数据）
+ 这个头部的目的不是确保数据的安全性，因为转换计算公式都是公开的，主要是为了预防一些常见的意外情况

#### 数据掩码的作用

数据掩码的作用是为了增强协议的安全性，但并不是为了保护数据本身，因为算法本身是公开的

安全并不是为了防止数据泄密，而是为了防止早期版本协议中存在的代理缓存污染攻击

### DNS系统

#### 域名服务器

+ 根域名服务器：13台根服务器，从a.root-servers.net到m.root-servers.net，会有很多台主机共用一个根服务器域名

  包含了所有顶级域名服务器的域名和IP地址，首先查看顶级域名例如.com然后将顶级域名服务器的IP地址返回给本地域名服务器

  或者逐层的查找直到查找到域名对应的IP地址

+ 顶级域名服务器：.com、.net

  管理该顶级域名服务器注册的所有二级域名

+ 权限域名服务器

  负责一个区的域名服务器，对于某个公司的域名abc.com，负责该区下的主机的域名解析，如果还有子域名y.abc.com，就会将该子域名单独作为一个区，需要一台独立的域名服务器

+ 本地域名服务器

  当一个主机发出DNS查询请求时，这个查询请求报文发给本地域名服务器，一半本地域名服务器离主机时最近的

  如果本地域名服务器没有有关域名的映射关系，转发给根域名服务器

#### 递归查询

+ 主机查询本地域名服务器
+ 如果本地域名服务器无法解析，向根域名服务器求助解析
+ 根域名服务器根据顶级域名，向对应的顶级域名服务器寻求解析
+ 如果顶级域名服务器无法解析，继续向权限域名服务器解析
+ 查询到IP地址后，向上传递给主机

#### 迭代查询

+ 主机查询本地域名服务器
+ 如果本地域名服务器无法解析，向根域名服务器求助解析
+ 根域名服务器返回对应的顶级域名服务器的IP地址，然后由本地域名服务器向顶级域名服务器解析
+ 如果顶级域名服务器无法解析，继续返回下层的权限域名服务器IP地址
+ 返回IP地址

#### 高速缓存

缓存以及查询过的域名和IP的映射地址

#### Q & A

##### 全球DNS根服务器为什么只有13台？

> UDP能保证正常工作的最大包长是512字节（超出部分会被截断），因为在DNS解析时使用的UDP协议，因此如果要传输所有根DNS服务器的数据都放在一个包中，根服务器的数量只能限制在13个，
>
> 当我们查询根域（.）（默认每个域名的顶级域名都会有一个英文句号.作为根域名）的NS记录时，512字节只够返回13个根域名服务器的NS记录和A记录的响应

1994年，全世界共有9台根域名服务器，DNS响应已经十分接近UDP的512字节的极限，这9台的DNS响应报文的大小为389字节

根据RFC 791规定，为保证UDP数据包传输成功率，尽量数据包控制在571字节使数据包不会被分片传输，再除去UDP数据包自身包头占用的字节数，DNS数据包被设计为不超过512字节

**数据包各部分字节占用**

+ Header部分占用12个字节

  + Transaction ID：2字节
  + Flags
  + Questions
  + Answer RRs
  + Authority RRs
  + Additional RRs

+ Question Section：5字节

  + 根标签：1字节
  + Class：2字节，基本都是IN
  + 查询类型：2字节

+ Answer Section：所有记录字节数之和

  + 每条记录包括根标签1字节、TTL4字节、Class2字节、查询类型2字节，域名存储占用的字节数

  + 域名在DNS解析协议中按照长度2字节+数据的形式存储，其中数据部分分段存储，例如

    <img src="/Users/zhanzhiguo/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Temp/ScreenCapture/企业微信截图_ab6e47f0-3f04-4c6a-abf2-15f413116fbf.png" alt="企业微信截图_ab6e47f0-3f04-4c6a-abf2-15f413116fbf" style="zoom:67%;" />

    所以第一条记录域名存储占用22个字节，总共占用9+22=31个字节

    第二条记录开始因为我记录中出现的域名存在部分内容与第一条记录重复（root-servers.net），因此只需要利用DNS指针压缩，存储，存储2个字节的指针即可，指向第一条记录出现的部分，而不需要存储实际内容，所以第二条记录之后的记录占用的字节数分别为11+4=15个字节

+ Additional Section：占用的字节数为所有记录字节数之和

  每条记录包括域名、TTL4字节、Class2字节、查询类型2字节，IP地址2字节长度+4字节内容，因为Additional Section记录的域名在Answer Section中都出现过，所以这部分可以利用DNS指针压缩存储，只需要存储2个字节的指针即可表示对应的域名，所以AS部分的记录占用的字节数为2+4+2+2+6=16字节

由上面数据包组成可以得到数据包总长度为12+5+31+15*（n-1）+16*n<=512得到n不能超过15组，考虑预留一些缓存，因此只搭建了13台根域名服务器

##### 根域名服务器的数量问题——DNS的任播

> DNS是任播最成功的应用，今天所有的根域名的服务器都部署在任播上，节点遍布全球
>
> 全球共有1089个根域名服务器节点，由12个组织负责运营。我国一共有26个根域名服务器节点
>
> IPv6中国一共部署了4台根域名服务器，1台主根和3台辅根

##### DNS中的TCP和UDP

**区域传送时使用TCP**

+ 辅域名服务器会定时向主域名服务器进行查询一遍了解数据是否有变动，有变动则会执行一次区域传送，执行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要很多

**域名解析时使用UDP**

+ 客户端向DNS服务器查询域名，一般返回的内容不会超过512字节，用UDP传输，不需要TCP的三次握手，可以降低DNS服务器的负载
+ 虽然客户端也可以指定向服务器查询的时候使用TCP，但是很多DNS服务器进行配置时仅支持UDP查询包

### 传输层协议（TCP、UDP）

### 网络层协议（IP）

### TCP/IP五层模型

### OSI七层模型











































