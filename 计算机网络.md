# 计算机网络

### 深入HTTPS

#### SSL握手过程

在开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手

+ 首先，客户端会给出支持的协议版本号、客户端生成的随机数，以及客户端支持的加密方法
+ 服务端确认双方的加密方法后，给出自己的数字证书，以及服务端生成的一个随机数
+ 客户端在确认证书有效后，生成一个新的随机数，并用数字证书中的公钥加密这个随机数，发给服务端
+ 服务端使用自己的私钥解密第三个随机数
+ 客户端和服务端根据约定的加密方法，使用前面交换的三个随机数，生成一个对话密钥（session key），加密接下来的整个对话过程

![](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092004.png)

#### 私钥的作用

+ 生成对话密钥一共需要三个随机数
+ 握手之后的对话使用对话密钥进行加密，也就是对称加密，服务器的公钥和私钥只用于加密和解密对话密钥（非对称加密），没有其他作用
+ 服务器的公钥存放在服务器的数字证书中

整个对话过程中给你，服务器的公钥和私钥只需要用到一次

#### DH算法的握手阶段

毫无疑问，整个握手阶段都不会进行加密，都是明文传输。因此，如果有人窃听通信，就可以知道双方选择的加密方法，以及三个随机数中的两个，整个通话的安全只取决于第三个随机数是否会被破解。

虽然理论上只要服务器的公钥足够长，那么第三个随机数就可以保证不被破解。但是为了足够安全，可以考虑把握手阶段的算法从默认的RSA算法改为DH算法。

采用DH算法后iu，第三个参数Premaster secret不需要传递，只要交换各自的参数就可以算出随机数。

<img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092008.png" style="zoom:200%;" />

#### session的恢复

握手阶段用来建立SSL连接，如果出于某种原因对话中断了，就需要重新握手

有两种方法可以恢复原来的session：

+ session ID
+ session ticket

session的思想很简单，就是每一次对话都有一个编号session ID，如果对话中断，下次重连时，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的对话密钥，不需要重新协商。

![](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092010.png)

##### 缺点

session ID是目前所有浏览器支持的方法，但是缺点在于session ID只保留在一台服务器上。所以如果客户端的请求发到另一个服务器，

就无法恢复对话，所以有了session ticket。

![](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092012.png)

在上面，客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密后的，只有服务器才能解密，其中包括了本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket后，揭秘后就不必重新生成对话密钥了。

### HTTP系列全集（1.0、1.1、2.0、3.0）

### HTTP（状态码、请求头、请求方法）

### Websocket

https://juejin.cn/post/6844903544978407431#heading-13

WebSocket最大的意义的就是让浏览器可以实时的双向通信，因为我们知道的所有HTTP协议（1.0，1.1，2.0乃至是3）都只能通过请求响应式应答，无法脱离请求主动发出消息

主要介绍：

+ WebSocket如何建立连接
+ 如何交换数据
+ 数据帧的格式
+ 针对WebSocket的安全攻击
+ WebScket如何抵御攻击

#### 什么是WebSocket

HTML5提供的一种浏览器与服务器进行全双工通信的网络技术，应用层协议（同HTTP），与HTTP3之前的协议一样，它基于TCP并复用了HTTP的握手通道

#### 优点

+ 支持双向通信

+ 更好的二进制支持

+ 较少的控制开销

  创建连接时，ws客户端和服务端数据交换时协议控制的数据包头部较小。不包含头部时，服务端到客户端的包头只有2-10字节（取决于数据包长度），客户端到服务端，需要加上额外的4字节掩码，而HTTP协议每次通信都需要携带完整的头部

+ 支持扩展

  ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议

#### 学习什么

+ 如何建立连接
+ 如何交换数据
+ 数据帧格式
+ 如何维持连接

#### 入门例子

##### 服务端

它监听了8080端口，当有新的连接请求到达时，打印日志，并向客户端发送消息

当收到来自客户端消息时，同样打印日志

```javascript
var app = require('express')();
var server = require('http').Server(app);
var WebSocket = require('ws');

var wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', function connection(ws) {
    console.log('server: receive connection.');
    
    ws.on('message', function incoming(message) {
        console.log('server: received: %s', message);
    });

    ws.send('world');
});

app.get('/', function (req, res) {
  res.sendfile(__dirname + '/index.html');
});

app.listen(3000);
```

##### 客户端

向8080端口发起WebSocket连接，连接建立后，打印日志，同时发送消息给服务端

接收到来自服务端的消息后，同样打印日志

```html
<script>
  var ws = new WebSocket('ws://localhost:8080');
  ws.onopen = function () {
    console.log('ws onopen');
    ws.send('from client: hello');
  };
  ws.onmessage = function (e) {
    console.log('ws onmessage');
    console.log('from server: ' + e.data);
  };
</script>
```

#### 如何建立连接

WebSocket复用了HTTP的握手通道，客户端通过HTTP请求与WebSocket服务端协商升级协议

协议升级完成后，后续的数据交换都通过WebSocket协议

##### 客户端申请协议升级

客户端发起协议升级请求，采用标准的HTTP报文格式，只支持GET方法

下面只是一些重点的请求头部，因为是标准的HTTP请求，类似Host、Origin、Cookie等请求头都会发送

```http
GET / HTTP/1.1
Host: localhost:8080
Origin: http://127.0.0.1:3000
// 表示要升级协议
Connection: Upgrade
// 要升级到websocket协议
Upgrade: websocket
// websocket版本，如果服务端不支持，应返回Sec-WebSocket-Version的header，包含服务端支持的版本号
Sec-WebSocket-Version: 13
// 与后面服务端响应首部的Sec-WebSocket-Accept配套，提供基本的防护，防止恶意的连接或无意的连接
Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==
```

##### 服务端响应协议升级

状态101表示1协议切换，到此完成协议升级，后续的数据交互按照新的协议来

```http
HTTP/1.1 101 Switching Protocols
Connection:Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=
```

##### Sec-WebSocket_Accept的计算

Sec-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来

计算公式：

+ 将Sec-WebSocket-Key与258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接
+ 通过SHA1计算出摘要，并转成base64字符串

```javascript
const crypto = require('crypto');
const magic = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
const secWebSocketKey = 'w4v7O6xFTi36lq3RNcgctw==';

let secWebSocketAccept = crypto.createHash('sha1')
	.update(secWebSocketKey + magic)
	.digest('base64');

console.log(secWebSocketAccept);
// Oy4NRAQ13jhfONC7bP8dTKb4PTU=
```

#### 数据帧格式

客户端、服务端数据的交换，离不开数据帧格式的定义，因此我们需要了解一些WebSocket的数据帧格式

WebSocket客户端、服务端通信的最小单位是帧frame，由1个或多个帧组成一条完整message

+ 发送端：将消息切割成多个帧，并发送给服务端
+ 接受端：接受消息帧，并将关联的帧重新组装成完整的message

##### 格式概览

从左到右，单位是bit，比如FIN、RSV1/2/3各占据1bit，opcode占据4bit

内容包括标识位、操作代码opcode、掩码mask、数据、数据长度

```
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
```

##### 数据帧格式详解

+ FIN：1bit，可以参考TCP，如果FIN位是1，表示这是message的最后一个fragment，如果是0表示还有其他分片

+ RSV1/2/3：1bit，一般全为0，当客户端、服务端协商采用WebSocket扩展时，三个标志位可以非0，且值的含义由扩展定义

  如果出现非0值，且没有采用WebSocket扩展，连接出错

+ Opcode：4bit，操作代码，决定了应该如何解析后续的数据载何（Data Payload）

+ Mask：1bit，表示是否要对数据载荷进行掩码操作，从客户端向服务端发送数据时，需要对开数据进行掩码擦欧总；从服务端向客户端发送数据时，不需要进行掩码操作

  如果服务端收到了没有过掩码操作的数据，需要断开连接

+ Payload length：数据载荷长度，7bit或7+16bit或1+64bit，不包括Masking-key的长度

+ Masking-key：0或4bit，从客户端传输到服务端的数据帧，数据载荷都要掩码操作，Mask为1，会携带Masking-key，为0则没有

+ Payload data：x+y bit，扩展数据x bit+应用数据y bit

##### 掩码算法

- original-octet-i：为原始数据的第i字节。
- transformed-octet-i：为转换后的数据的第i字节。
- j：为`i mod 4`的结果。
- masking-key-octet-j：为mask key第j字节。

```
j = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j
```

#### 数据传递

一旦建立连接，后续的操作都是基于数据帧的传递

WebSocket根据opcode区分操作的类型，比如0x8表示断开连接，0x0-0x2表示数据交互

##### 数据分片

WebSocket的每条message都会被切分成多个frame，当接收方收到一个frame时，会根据FIN值判断是否为最后一个frame

FIN1表示最后一个frame，可以处理完整的消息，FIN0表示需要继续监听接受剩余的数据帧

opcode在数据交换场景下，表示数据类型

+ 0x08表示文本
+ 0x02表示二进制
+ 0x00表示延续帧，完整消息对应的数据帧还未接受完

##### 数据分片例子

```
Client: FIN=1, opcode=0x1, msg="hello"
Server: (process complete message immediately) Hi.
Client: FIN=0, opcode=0x1, msg="and a"
Server: (listening, new message containing text started)
Client: FIN=0, opcode=0x0, msg="happy new"
Server: (listening, payload concatenated to previous message)
Client: FIN=1, opcode=0x0, msg="year!"
Server: (process complete message) Happy new year to you too!
```

#### 连接保持+心跳

WebSocket为了保持客户端、服务端的实时双向痛惜你，需要确保客户端和服务端的TCP通道保持连接没有断开

但是，如果长时间没有数据往来，保持着会浪费包括的连接资源

采用心跳保持客户端与服务端的长时间连接

+ 发送方给接收方：ping

+ 接收方给发送方：pong

ping和pong对应WebSocket的两个控制帧，opcode对应0x9和0xA

```javascript
// WebSocket服务端向客户单发送pingws.ping('', false, true);
```

#### Sec-WebSocket-Key/Accept的作用

> 提供基础的防护，避免恶意连接和意外连接

+ 避免服务端收到非法的websocket连接，http客户端不小心连接到websocket服务
+ 确保服务端立即ws连接，因为ws在握手阶段仍然采用http协议，因此ws连接可能会被http服务器处理返回，这个头部可以避免，但不能预防无聊的http服务器故意处理这个头部但不实现ws协议
+ 发起ajax请求时，设置header时，ws有关的头部会被禁止携带，防止不需要的请求升级
+ 防止反向代理返回错误的数据，比如反向代理前后收到两次ws连接的升级请求，把第一次请求的返回cache，第二次直接返回（会出现脏数据）
+ 这个头部的目的不是确保数据的安全性，因为转换计算公式都是公开的，主要是为了预防一些常见的意外情况

#### 数据掩码的作用

数据掩码的作用是为了增强协议的安全性，但并不是为了保护数据本身，因为算法本身是公开的

安全并不是为了防止数据泄密，而是为了防止早期版本协议中存在的代理缓存污染攻击

### DNS系统

#### 域名服务器

+ 根域名服务器：13台根服务器，从a.root-servers.net到m.root-servers.net，会有很多台主机共用一个根服务器域名

  包含了所有顶级域名服务器的域名和IP地址，首先查看顶级域名例如.com然后将顶级域名服务器的IP地址返回给本地域名服务器

  或者逐层的查找直到查找到域名对应的IP地址

+ 顶级域名服务器：.com、.net

  管理该顶级域名服务器注册的所有二级域名

+ 权限域名服务器

  负责一个区的域名服务器，对于某个公司的域名abc.com，负责该区下的主机的域名解析，如果还有子域名y.abc.com，就会将该子域名单独作为一个区，需要一台独立的域名服务器

+ 本地域名服务器

  当一个主机发出DNS查询请求时，这个查询请求报文发给本地域名服务器，一半本地域名服务器离主机时最近的

  如果本地域名服务器没有有关域名的映射关系，转发给根域名服务器

#### 递归查询

+ 主机查询本地域名服务器
+ 如果本地域名服务器无法解析，向根域名服务器求助解析
+ 根域名服务器根据顶级域名，向对应的顶级域名服务器寻求解析
+ 如果顶级域名服务器无法解析，继续向权限域名服务器解析
+ 查询到IP地址后，向上传递给主机

#### 迭代查询

+ 主机查询本地域名服务器
+ 如果本地域名服务器无法解析，向根域名服务器求助解析
+ 根域名服务器返回对应的顶级域名服务器的IP地址，然后由本地域名服务器向顶级域名服务器解析
+ 如果顶级域名服务器无法解析，继续返回下层的权限域名服务器IP地址
+ 返回IP地址

#### 高速缓存

缓存以及查询过的域名和IP的映射地址

#### Q & A

##### 全球DNS根服务器为什么只有13台？

> UDP能保证正常工作的最大包长是512字节（超出部分会被截断），因为在DNS解析时使用的UDP协议，因此如果要传输所有根DNS服务器的数据都放在一个包中，根服务器的数量只能限制在13个，
>
> 当我们查询根域（.）（默认每个域名的顶级域名都会有一个英文句号.作为根域名）的NS记录时，512字节只够返回13个根域名服务器的NS记录和A记录的响应

1994年，全世界共有9台根域名服务器，DNS响应已经十分接近UDP的512字节的极限，这9台的DNS响应报文的大小为389字节

根据RFC 791规定，为保证UDP数据包传输成功率，尽量数据包控制在571字节使数据包不会被分片传输，再除去UDP数据包自身包头占用的字节数，DNS数据包被设计为不超过512字节

**数据包各部分字节占用**

+ Header部分占用12个字节

  + Transaction ID：2字节
  + Flags
  + Questions
  + Answer RRs
  + Authority RRs
  + Additional RRs

+ Question Section：5字节

  + 根标签：1字节
  + Class：2字节，基本都是IN
  + 查询类型：2字节

+ Answer Section：所有记录字节数之和

  + 每条记录包括根标签1字节、TTL4字节、Class2字节、查询类型2字节，域名存储占用的字节数

  + 域名在DNS解析协议中按照长度2字节+数据的形式存储，其中数据部分分段存储，例如

    <img src="/Users/zhanzhiguo/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Temp/ScreenCapture/企业微信截图_ab6e47f0-3f04-4c6a-abf2-15f413116fbf.png" alt="企业微信截图_ab6e47f0-3f04-4c6a-abf2-15f413116fbf" style="zoom:67%;" />

    所以第一条记录域名存储占用22个字节，总共占用9+22=31个字节

    第二条记录开始因为我记录中出现的域名存在部分内容与第一条记录重复（root-servers.net），因此只需要利用DNS指针压缩，存储，存储2个字节的指针即可，指向第一条记录出现的部分，而不需要存储实际内容，所以第二条记录之后的记录占用的字节数分别为11+4=15个字节

+ Additional Section：占用的字节数为所有记录字节数之和

  每条记录包括域名、TTL4字节、Class2字节、查询类型2字节，IP地址2字节长度+4字节内容，因为Additional Section记录的域名在Answer Section中都出现过，所以这部分可以利用DNS指针压缩存储，只需要存储2个字节的指针即可表示对应的域名，所以AS部分的记录占用的字节数为2+4+2+2+6=16字节

由上面数据包组成可以得到数据包总长度为12+5+31+15*（n-1）+16*n<=512得到n不能超过15组，考虑预留一些缓存，因此只搭建了13台根域名服务器

##### 根域名服务器的数量问题——DNS的任播

> DNS是任播最成功的应用，今天所有的根域名的服务器都部署在任播上，节点遍布全球
>
> 全球共有1089个根域名服务器节点，由12个组织负责运营。我国一共有26个根域名服务器节点
>
> IPv6中国一共部署了4台根域名服务器，1台主根和3台辅根

##### DNS中的TCP和UDP

**区域传送时使用TCP**

+ 辅域名服务器会定时向主域名服务器进行查询一遍了解数据是否有变动，有变动则会执行一次区域传送，执行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要很多

**域名解析时使用UDP**

+ 客户端向DNS服务器查询域名，一般返回的内容不会超过512字节，用UDP传输，不需要TCP的三次握手，可以降低DNS服务器的负载
+ 虽然客户端也可以指定向服务器查询的时候使用TCP，但是很多DNS服务器进行配置时仅支持UDP查询包

## 传输层协议（TCP、UDP）

因为网络层的IP协议，只提供最大努力交付是不可靠传输

而传输层既可以使用TCP协议实现可靠传输，也可以使用UDP协议同样最大努力交付，然后由应用层提供可靠服务

### 功能

+ 提供进程与进程之间的通信

  网络层是主机与主机之间的通信

+ 复用和分用

+ 传输层对收到的报文进行差错检测

+ TCP和UDP

### TCP VS UDP

+ TCP是面向连接的传输控制协议，UDP是无连接的用户数据报协议

+ TCP比UDP更加可靠

+ TCP的时延较大，UDP的时延小

+ TCP适用于大文件，UPD适用于小文件

  例如QQ中的某条消息，因为内容不大，因此可以采用UDP传输可以更快，没有必要每次发送都建立一个连接

  如果发送失败，会提醒重新发送

### 寻址与端口

+ 复用：应用层所有的应用进程都可以通过传输层再传输到网络层
+ 分用：传输层从网络层收到数据后交付指明的应用进程

端口时传输层的SAP，标识主机中的应用进程

端口好只有本地意义，不同计算机的相同端口没有联系

#### 端口号

> 16bit，可以表示65536个不同的端口号

+ 服务端
  + 熟知端口号：给TCP/IP最重要的一些应用程序，让所有用户知道，0-1023
  + 登记端口号：为没有熟知端口号的应用程序使用，1024-49151
+ 客户端：在客户进程运行时动态选择，49152-65535

### TCP

#### 特点

+ 面向连接（虚连接，并不是实际的物理连接）的传输层协议，在两个进程之间建立的端口之间的连接

+ 只能是点对点的

+ 可靠有序，不丢失不重复

+ 提供全双工通信，两端可以同时发送和接收数据，两端都会有发送缓存和接收缓存

  + 发送缓存：准备发送的数据和已发送但未收到确认的数据
  + 接收缓存：按序到达但尚未被接收应用程序读取的数据和不按序到达的数据，只有排好顺序后才可以被接收

+ 面向字节流

  TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流

#### TCP报文段首部格式

+ 序号seq：在一个TCP连接中传送的字节流中的每个字节都按顺序编号，本字段表示本报文段发送数据的第一个字节的序号

+ 确认号ack：期望收到对方下一个报文段的第一个数据字节的序号，若确认好为N，说明到序号N-1为止的所有数据都已正确收到

+ 数据偏移（首部长度）：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位

  因为数据偏移是4个字节，所以如果是1111的话，那么就是表示为15*4B，所以首部长度为60B，又因为TCP有20B的固定首部

  因此选项和填充字段占据40B，知道了首部长度，也就可以知道TCP报文段中从哪里开始是实际的数据部分

+ 紧急位URG：URG为1时，表明此报文段有紧急数据，是高优先级的，应该尽快传送，不用在缓存中排队，配合紧急指针字段使用

  URG=1可以让报文段不用在TCP缓存中等待，优先发送

+ 确认为ACK

+ 推送位PSH：PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付

  与URG不同，PSH是在接收方的统一处理，PSH=1表示该报文段应尽快交付给上层的进程

+ 复位RST：RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后重新建立传输连接

+ 同步为SYN：SYN=1时，表明是一个连接请求或接受报文

+ 终止位FIN：FIN=1时，表明此报文段发送方数据已发完，要求释放连接

+ 窗口：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量

  16位，0-2^16-1，根据接收方窗口大小，限制发送方窗口大小，如果发送方发送确认号ack=701，窗口大小为1000；那么接收方只能容纳1000字节，因此是701-1700

+ 校验和：检验首部和数据，检验时要加上12B伪首部，第四个字段为6

+ 紧急指针：URG=1时才有意义，指出本报文段中紧急数据的字节数

+ 选项：最大报文段长度MSS、窗口扩大、时间戳、选择确认

+ 填充：如果选项长度不是4B的整数倍，就需要对头部进行填充，因为上面说过首部长度的单位是4B

#### TCP连接管理

TCP面向连接建立点对点的通信，全双工通信，既可以接收也可以发送

+ 建立连接
+ 传输数据
+ 释放连接

主动发起连接建立的应用进程叫做客户，被动等待连接建立的应用进程叫做服务器

**三次握手**

+ 客户端发送连接请求报文段，无应用层数据

  SYN=1，一个随机生成的seq序列号seq=x

+ 服务器端为该TCP连接分配发送和接收缓存，并向客户端返回确认报文段，允许连接，无应用层数据

  SYN=1，ACK=1，一个随机生产段seq序列号seq=y，ack=x+1，这里注意ack是期待对方发送的下一个报文段的起始位置，也就是对方上次发送的报文段的序列号seq+1

+ 客户端为该TCP连接分配缓存，并向服务器端返回确认的确认，可以携带数据

  SYN=0，ACK=1，seq=x+1，ack=y+1

+ 三次握手的原因：

  为了防止失效的连接请求到达服务器，让服务器错误打开连接

  客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传的时间之后，就会重新请求连接。但是滞留的连接请求最后还是会到达服务器，如果不进行三次握手，服务器就会打开两个连接

  如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接Queen，不进行三次握手就不会再次打开连接

**SYN泛洪攻击**

大量半连接状态的TCP连接

解决：SYN cookie

**四次挥手**

因为TCP是全双工通信，因此任一方都可以释放连接

+ 客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接

  FIN=1，seq=u，u取决于服务端发送的上一个报文段序列号

+ 服务端回送一个确认报文段，客户到服务器这个方向的连接释放，客户端处于半关闭状态

  ACK=1，seq=v，ack=u+1，v同u

+ 服务器端发送完数据后，发出连接释放的报文段，主动关闭TCP连接

  FIN=1，ACK=1，seq=w，w也取决于上一个报文段序列号，ack=u+1，因为这个过程中客户端并没有发送报文段过来，因此期待的报文段序列号不会改变

+ 客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭

  + 因为如果服务端在发送确认报文段后没有收到客户端的确认ACK，那么就会重新发送确认报文段，客户端发送ACK的时间和服务端重新发送ACK的时间加起来就是2MSL。也就是说，如果在2MSL时间内，客户端没有收到服务端的重传ACK，就会关闭连接

    如果不等待2MSL，会导致服务端一直收不到客户端的确认ACK，因此服务端会一直重发ACK确认报文段，同样也无法释放连接

  + 为了让本连接持续时间内所产生的所有报文从网络中消失，避免下一个新的连接出现旧的连接请求报文

#### TCP可靠传输

可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一样

虽然TCP是面向字节流的，但是TCP发送时会把多个字节组成一个报文段发送，报文段的序列号为第一个字节的序列号（每个字节都有以一个序列号）

TCP使用**超时重传**来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，就重传这个报文段

一个报文段从发送再到接收到确认经过的时间称为往返RTT，加权往返时间RTTs计算如下：

![](https://camo.githubusercontent.com/4b31b44c078c2a6fe1354e38006e624c3ae5af66ad3f982d3d73e220a120ab98/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f525454733d28312d61292a2852545473292b612a525454)

其中，0<=a<1，RTTs随着a的增加更容易受到RTT的影响

超时时间RTO，应该略大于RTTs

![](https://camo.githubusercontent.com/ae415414727a193c7c23b73199e5ca6c1caa84df9822bf02f8483f8a359605e0/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f52544f3d525454732b342a5254545f64)

RTTd为偏差的加权平均值

#### TCP滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

![](https://camo.githubusercontent.com/f670e3a7df385079035c54d43f156e63bde8c01b320e1ee40f4060a097c4dad9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61333235336465622d386432312d343061312d616165342d3764313738653461613331392e6a7067)

#### 流量控制

> 利用滑动窗口机制实现流量控制
>
> 在通信过程中，接收方根据自己接收缓存的大小，动态调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给对方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。·

<img src="/Users/zhanzhiguo/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Temp/ScreenCapture/企业微信截图_fa75089f-2065-4589-bd2e-84fdd738f7bc.png" alt="企业微信截图_fa75089f-2065-4589-bd2e-84fdd738f7bc" style="zoom:50%;" />

+ 首先，在建立连接时，主机B给主机A发送一个rwnd字段表示接收窗口大小，接收窗口大小会限制主机A能发送的报文大小
+ 中途如果有报文丢失，主机B会在收到三次冗余ACK后重新发送丢失的报文
+ 如果rwnd为0，发送方会一直等待接收窗口发送下一个确认报文中的rwnd字段，并且开启一个持续计时器，定时器到期如果还没有收到确认报文，就发送一个零窗口1字节的探测报文段，主机B收到报文后会给出现在的rwnd，如果仍然为0，主机A会重新启动持续计时器。

#### TCP拥塞控制

**产生拥塞的条件：**

+ 对资源需求的总和 > 可用资源，例如网络带宽不足以支持网络中的报文传输

+ 网络中许多资源同时呈现供应不足，导致网络性能变坏，网络吞吐量将随输入负荷增大而下降

**拥塞的目的**

防止过多的数据注入到网络中

> 流量控制是点对点之间的问题，拥塞控制是很多主机之间的问题

**拥塞控制过程中的一些假定**

+ 数据单方向传送，另一个方向只发送确认， 实际上，会有发送数据时候的捎带确认

+ 接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度

  发送窗口=Min（接收窗口rwnd，拥塞窗口cwnd）

  接收窗口：接收方根据接收缓存设置的值，并告知给发送方，反映接收方容量

  拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量

**慢开始**

在最开始的部分，将cwnd大小设置为1个报文段，所以叫慢开始，然后指数增长

一收到上一轮窗口发送到报文的确认后，就将cwnd指数增长一次

**拥塞避免**

ssthresh：慢开始门限，cwnd到达慢开始门限后，进入拥塞避免阶段，每次cwnd只会线性增长到网络拥塞阶段

在网络拥塞阶段时，立即将cwnd除2得到新的ssthresh

**快重传**

当同时发送5个报文段后，编号为1、2、3、4、5，如果发送过程中2号报文丢失，那么接收端因为没有收到2号报文段，所以对于3、4、5报文段的返回ack也是2，表示下一个期待的报文是2号报文，发送端在连续三次收到冗余ACK后，会执行快重传算法，立即重传丢失的2号报文，然后将cwnd拥塞窗口的大小降为新的ssthresh慢开始门限（当前cwnd的一半）

**快恢复**

在快重传后，将拥塞窗口大小cwnd降为新的慢开始门限而不是最小的慢开始值1

<img src="/Users/zhanzhiguo/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Temp/ScreenCapture/企业微信截图_d9f92c5e-3bfa-4793-8eb4-86a489be32eb.png" alt="企业微信截图_d9f92c5e-3bfa-4793-8eb4-86a489be32eb" style="zoom:50%;" />



### UDP

> 只在IP数据报服务之上增加很少的功能，即复用分用和差错检测功能

#### 特点

+ 无连接，可以减少开销和发送数据之前的时延

  不需要建立连接、维护连接、释放连接

+ 最大努力交付，不保证可靠交付

+ 面向报文，适合一次性传输少量数据的网络应用

  + 应用层报文

  + UDP首部+UDP用户数据报数据部分

    对于应用层传下来的报文，既不合并也不拆分，而是保留报文边界都放到传输层的UPD数据报中

    如果应用层报文太长，网络层需要分片

    如果应用层报文太小，IP数据包的首部相比数据部分占比太大，降低传输效率，因为我们主要传输的是数据，而不是首部这些附加信息

  + IP首部+IP数据报数据部分

+ UDP无拥塞控制，适合很多实时应用

  因为没有拥塞控制，所以发送方处不会发生拥塞，比如在视频通话时，即使过程中丢失了一两帧，也没有太大关系

+ UDP首部开销小，8字节，TCP20字节

#### UDP首部格式

+ 16位源端口号：可有可无，因为不一定需要回应

+ 16位目的端口号

+ 16位UDP长度：用户数据报的长度

+ 16位UDP校验和：检测UDP数据报是否有错，错误就丢弃

  分用时，如果找不到对应的目的端口号，丢弃报文，并给发送方发送ICMP端口不可达的差错报文

+ 数据（未知长度）

<img src="https://camo.githubusercontent.com/513fdc176a3598465859ee974e9217e2cc0f4e14dbf6c0d0cd03d611865bb3b1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64346333613461312d303834362d343665632d396363332d6561646466636137313235342e6a7067" style="zoom:50%;" />

首部字段只有8个字节，包括源端口、目标端口、长度和检验和，12字节的伪首部是为了计算检验和临时添加的

在计算完检验和之后就会将伪首部去掉，然后将UDP首部连接UDP的数据部分，最后传入IP层

### 网络层协议（IP）

### TCP/IP五层模型

### OSI七层模型











































