# 传输层

https://www.bilibili.com/video/BV19E411D78Q?p=65&spm_id_from=pageDriver

> 因为网络层的IP协议，只提供最大努力交付是不可靠传输
>
> 而传输层既可以使用TCP协议实现可靠传输，也可以使用UDP协议同样最大努力交付，然后由应用层提供可靠服务

### 功能

> + 提供进程与进程之间的通信
>
>   网络层是主机与主机之间的通信
>
> + 复用和分用
>
> + 传输层对收到的报文进行差错检测
>
> + TCP和UDP

### TCP VS UDP

> + TCP是面向连接的传输控制协议，UDP是无连接的用户数据报协议
>
> + TCP比UDP更加可靠
>
> + TCP的时延较大，UDP的时延小
>
> + TCP适用于大文件，UPD适用于小文件
>
>   例如QQ中的某条消息，因为内容不大，因此可以采用UDP传输可以更快，没有必要每次发送都建立一个连接
>
>   如果发送失败，会提醒重新发送

### 寻址与端口

> + 复用：应用层所有的应用进程都可以通过传输层再传输到网络层
> + 分用：传输层从网络层收到数据后交付指明的应用进程
>
> 端口时传输层的SAP，标识主机中的应用进程
>
> 端口好只有本地意义，不同计算机的相同端口没有联系

#### 端口号

> 16bit，可以表示65536个不同的端口号

+ 服务端
  + 熟知端口号：给TCP/IP最重要的一些应用程序，让所有用户知道，0-1023
  + 登记端口号：为没有熟知端口号的应用程序使用，1024-49151
+ 客户端：在客户进程运行时动态选择，49152-65535

### UDP

> 只在IP数据报服务至上增加很少的功能，即复用分用和差错检测功能

#### 特点

+ 无连接，可以减少开销和发送数据之前的时延

  不需要建立连接、维护连接、释放连接

+ 最大努力交付，不保证可靠交付

+ 面向报文，适合一次性传输少量数据的网络应用

  + 应用层报文

  + UDP首部+UDP用户数据报数据部分

    对于应用层传下来的报文，既不合并也不拆分，而是保留报文边界都放到传输层的UPD数据报中

    如果应用层报文太长，网络层需要分片

    如果应用层报文太小，IP数据包的首部相比数据部分占比太大，降低传输效率，因为我们主要传输的是数据，而不是首部这些附加信息

  + IP首部+IP数据报数据部分

+ UDP无拥塞控制，适合很多实时应用

  因为没有拥塞控制，所以发送方处不会发生拥塞，比如在视频通话时，即使过程中丢失了一两帧，也没有太大关系

+ UDP首部开销小，8字节，TCP20字节

#### UDP首部格式

+ 16位源端口号：可有可无，因为不一定需要回应

+ 16位目的端口号

+ 16位UDP长度：用户数据报的长度

+ 16位UDP校验和：检测UDP数据报是否有错，错误就丢弃

  分用时，如果找不到对应的目的端口号，丢弃报文，并给发送方发送ICMP端口不可达的差错报文

+ 数据（未知长度）

<img src="https://camo.githubusercontent.com/513fdc176a3598465859ee974e9217e2cc0f4e14dbf6c0d0cd03d611865bb3b1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64346333613461312d303834362d343665632d396363332d6561646466636137313235342e6a7067" style="zoom:50%;" />

首部字段只有8个字节，包括源端口、目标端口、长度和检验和，12字节的伪首部是为了计算检验和临时添加的

在计算完检验和之后就会将伪首部去掉，然后将UDP首部连接UDP的数据部分，最后传入IP层

### TCP

#### 特点

+ 面向连接（虚连接，并不是实际的物理连接）的传输层协议，在两个进程之间建立的端口之间的连接

+ 只能是点对点的

+ 可靠有序，不丢失不重复

+ 提供全双工通信，两端可以同时发送和接收数据，两端都会有发送缓存和接收缓存

  + 发送缓存：准备发送的数据和已发送但未收到确认的数据
  + 接收缓存：按序到达但尚未被接收应用程序读取的数据和不按序到达的数据，只有排好顺序后才可以被接收

+ 面向字节流

  TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流

#### TCP报文段首部格式

+ 序号seq：在一个TCP连接中传送的字节流中的每个字节都按顺序编号，本字段表示本报文段发送数据的第一个字节的序号
+ 确认号ack：期望收到对方下一个报文段的第一个数据字节的序号，若确认好为N，说明到序号N-1为止的所有数据都已正确收到

+ 数据偏移（首部长度）：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位

  因为数据偏移是4个字节，所以如果是1111的话，那么就是表示为15*4B，所以首部长度为60B，又因为TCP有20B的固定首部

  因此选项和填充字段占据40B，知道了首部长度，也就可以知道TCP报文段中从哪里开始是实际的数据部分

+ 紧急位URG：URG为1时，表明此报文段有紧急数据，是高优先级的，应该尽快传送，不用在缓存中排队，配合紧急指针字段使用

  URG=1可以让报文段不用在TCP缓存中等待，优先发送

+ 确认为ACK

+ 推送位PSH：PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付

  与URG不同，PSH是在接收方的统一处理，PSH=1表示该报文段应尽快交付给上层的进程

+ 复位RST：RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后重新建立传输连接

+ 同步为SYN：SYN=1时，表明是一个连接请求或接受报文

+ 终止位FIN：FIN=1时，表明此报文段发送方数据已发完，要求释放连接

+ 窗口：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量

  16位，0-2^16-1，根据接收方窗口大小，限制发送方窗口大小，如果发送方发送确认号ack=701，窗口大小为1000；那么接收方只能容纳1000字节，因此是701-1700

+ 校验和：检验首部和数据，检验时要加上12B伪首部，第四个字段为6

+ 紧急指针：URG=1时才有意义，指出本报文段中紧急数据的字节数

+ 选项：最大报文段长度MSS、窗口扩大、时间戳、选择确认

+ 填充：如果选项长度不是4B的整数倍，就需要对头部进行填充，因为上面说过首部长度的单位是4B

#### TCP连接管理

> TCP面向连接建立点对点的通信，全双工通信，既可以接收也可以发送

+ 建立连接
+ 传输数据
+ 释放连接

主动发起连接建立的应用进程叫做客户，被动等待连接建立的应用进程叫做服务器

**三次握手**

> + 客户端发送连接请求报文段，无应用层数据
>
>   SYN=1，一个随机生成的seq序列号seq=x
>
> + 服务器端为该TCP连接分配发送和接收缓存，并向客户端返回确认报文段，允许连接，无应用层数据
>
>   SYN=1，ACK=1，一个随机生产段seq序列号seq=y，ack=x+1，这里注意ack是期待对方发送的下一个报文段的起始位置，也就是对方上次发送的报文段的序列号seq+1
>
> + 客户端为该TCP连接分配缓存和比那里，并向服务器端返回确认的确认，可以携带数据
>
>   SYN=0，ACK=1，seq=x+1，ack=y+1
>   
> + 三次握手的原因：
>
>   为了防止失效的连接请求到达服务器，让服务器错误打开连接
>
>   客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传的时间之后，就会重新请求连接。但是滞留的连接请求最后还是会到达服务器，如果不进行三次握手，服务器就会打开两个连接
>
>   如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接Queen，不进行三次握手就不会再次打开连接

**SYN泛洪攻击**

> 大量半连接状态的TCP连接
>
> 解决：SYN cookie

**四次挥手**

> 因为TCP是全双工通信，因此任一方都可以释放连接
>
> + 客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接
>
>   FIN=1，seq=u，u取决于服务端发送的上一个报文段序列号
>
> + 服务端回送一个确认报文段，客户到服务器这个方向的连接释放，客户端处于半关闭状态
>
>   ACK=1，seq=v，ack=u+1，v同u
>
> + 服务器端发送完数据后，发出连接释放的报文段，主动关闭TCP连接
>
>   FIN=1，ACK=1，seq=w，w也取决于上一个报文段序列号，ack=u+1，因为这个过程中客户端并没有发送报文段过来，因此期待的报文段序列号不会改变
>
> + 客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭
>
>   + 因为如果服务端在发送确认报文段后没有收到客户端的确认ACK，那么就会重新发送确认报文段，客户端发送ACK的时间和服务端重新发送ACK的时间加起来就是2MSL。也就是说，如果在2MSL时间内，客户端没有收到服务端的重传ACK，就会关闭连接
>
>     如果不等待2MSL，会导致服务端一直收不到客户端的确认ACK，因此服务端会一直重发ACK确认报文段，同样也无法释放连接
>   
>   + 为了让本连接持续时间内所产生的所有报文从网络中消失，避免下一个新的连接出现旧的连接请求报文

#### TCP可靠传输

> 可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一样
>
> 虽然TCP是面向字节流的，但是TCP发送时会把多个字节组成一个报文段发送，报文段的序列号为第一个字节的序列号（每个字节都有以一个序列号）

TCP使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，就重传这个报文段

一个报文段从发送再到接收到确认经过的时间称为往返RTT，加权往返时间RTTs计算如下：

![](https://camo.githubusercontent.com/4b31b44c078c2a6fe1354e38006e624c3ae5af66ad3f982d3d73e220a120ab98/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f525454733d28312d61292a2852545473292b612a525454)

其中，0<=a<1，RTTs随着a的增加更容易受到RTT的影响

超时时间RTO，应该略大于RTTs

![](https://camo.githubusercontent.com/ae415414727a193c7c23b73199e5ca6c1caa84df9822bf02f8483f8a359605e0/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f52544f3d525454732b342a5254545f64)

RTTd为偏差的加权平均值

#### TCP滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

![](https://camo.githubusercontent.com/f670e3a7df385079035c54d43f156e63bde8c01b320e1ee40f4060a097c4dad9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61333235336465622d386432312d343061312d616165342d3764313738653461613331392e6a7067)

#### 流量控制

> 利用滑动窗口机制实现流量控制
>
> 在通信过程中，接收方根据自己接收缓存的大小，动态调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给对方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。·

<img src="/Users/zhanzhiguo/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Temp/ScreenCapture/企业微信截图_fa75089f-2065-4589-bd2e-84fdd738f7bc.png" alt="企业微信截图_fa75089f-2065-4589-bd2e-84fdd738f7bc" style="zoom:50%;" />

+ 首先，在建立连接时，主机B给主机A发送一个rwnd字段表示接收窗口大小，接收窗口大小会限制主机A能发送的报文大小
+ 中途如果有报文丢失，主机B会在收到三次冗余ACK后重新发送丢失的报文
+ 如果rwnd为0，发送方会一直等待接收窗口发送下一个确认报文中的rwnd字段，并且开启一个持续计时器，定时器到期如果还没有收到确认报文，就发送一个零窗口1字节的探测报文段，主机B收到报文后会给出现在的rwnd，如果仍然为0，主机A会重新启动持续计时器。

#### TCP拥塞控制

**产生拥塞的条件：**

+ 对资源需求的总和 > 可用资源，例如网络带宽不足以支持网络中的报文传输

+ 网络中许多资源同时呈现供应不足，导致网络性能变坏，网络吞吐量将随输入负荷增大而下降

**拥塞的目的**

防止过多的数据注入到网络中

> 流量控制是点对点之间的问题，拥塞控制是很多主机之间的问题

**拥塞·控制过程中的一些假定**

+ 数据单方向传送，另一个方向只发送确认， 实际上，会有发送数据时候的捎带确认

+ 接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度

  发送窗口=Min（接收窗口rwnd，拥塞窗口cwnd）

  接收窗口：接收方根据接收缓存设置的值，并告知给发送方，反映接收方容量

  拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量

**慢开始**

在最开始的部分，将cwnd大小设置为1个报文段，所以叫慢开始，然后指数增长

一收到上一轮窗口发送到报文的确认后，就将cwnd指数增长一次

**拥塞避免**

ssthresh：慢开始门限，cwnd到达慢开始门限后，进入拥塞避免阶段，每次cwnd只会线性增长到网络拥塞阶段

在网络拥塞阶段时，立即将cwnd除2得到新的ssthresh

**快重传**

当同时发送5个报文段后，编号为1、2、3、4、5，如果发送过程中2号报文丢失，那么接收端因为没有收到2号报文段，所以对于3、4、5报文段的返回ack也是2，表示下一个期待的报文是2号报文，发送端在连续三次收到冗余ACK后，会执行快重传算法，立即重传丢失的2号报文，然后将cwnd拥塞窗口的大小降为新的ssthresh慢开始门限（当前cwnd的一半）

**快恢复**

在快重传后，将拥塞窗口大小cwnd降为新的慢开始门限而不是最小的慢开始值1

<img src="/Users/zhanzhiguo/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Temp/ScreenCapture/企业微信截图_d9f92c5e-3bfa-4793-8eb4-86a489be32eb.png" alt="企业微信截图_d9f92c5e-3bfa-4793-8eb4-86a489be32eb" style="zoom:50%;" />


