# 传输层

https://www.bilibili.com/video/BV19E411D78Q?p=65&spm_id_from=pageDriver

> 因为网络层的IP协议，只提供最大努力交付是不可靠传输
>
> 而传输层既可以使用TCP协议实现可靠传输，也可以使用UDP协议同样最大努力交付，然后由应用层提供可靠服务

### 功能

> + 提供进程与进程之间的通信
>
>   网络层是主机与主机之间的通信
>
> + 复用和分用
>
> + 传输层对收到的报文进行差错检测
>
> + TCP和UDP

### TCP VS UDP

> + TCP是面向连接的传输控制协议，UDP是无连接的用户数据报协议
>
> + TCP比UDP更加可靠
>
> + TCP的时延较大，UDP的时延小
>
> + TCP适用于大文件，UPD适用于小文件
>
>   例如QQ中的某条消息，因为内容不大，因此可以采用UDP传输可以更快，没有必要每次发送都建立一个连接
>
>   如果发送失败，会提醒重新发送

### 寻址与端口

> + 复用：应用层所有的应用进程都可以通过传输层再传输到网络层
> + 分用：传输层从网络层收到数据后交付指明的应用进程
>
> 端口时传输层的SAP，标识主机中的应用进程
>
> 端口好只有本地意义，不同计算机的相同端口没有联系

#### 端口号

> 16bit，可以表示65536个不同的端口号

+ 服务端
  + 熟知端口号：给TCP/IP最重要的一些应用程序，让所有用户知道，0-1023
  + 登记端口号：为没有熟知端口号的应用程序使用，1024-49151
+ 客户端：在客户进程运行时动态选择，49152-65535

### UDP

> 只在IP数据报服务至上增加很少的功能，即复用分用和差错检测功能

#### 特点

+ 无连接，可以减少开销和发送数据之前的时延

  不需要建立连接、维护连接、释放连接

+ 最大努力交付，不保证可靠交付

+ 面向报文，适合一次性传输少量数据的网络应用

  + 应用层报文

  + UDP首部+UDP用户数据报数据部分

    对于应用层传下来的报文，既不合并也不拆分，而是保留报文边界都放到传输层的UPD数据报中

    如果应用层报文太长，网络层需要分片

    如果应用层报文太小，IP数据包的首部相比数据部分占比太大，降低传输效率，因为我们主要传输的是数据，而不是首部这些附加信息

  + IP首部+IP数据报数据部分

+ UDP无拥塞控制，适合很多实时应用

  因为没有拥塞控制，所以发送方处不会发生拥塞，比如在视频通话时，即使过程中丢失了一两帧，也没有太大关系

+ UDP首部开销小，8字节，TCP20字节

#### UDP首部格式

+ 16位源端口号：可有可无，因为不一定需要回应

+ 16位目的端口号

+ 16位UDP长度：用户数据报的长度

+ 16位UDP校验和：检测UDP数据报是否有错，错误就丢弃

  分用时，如果找不到对应的目的端口号，丢弃报文，并给发送方发送ICMP端口不可达的差错报文

+ 数据（未知长度）

### TCP

#### 特点

+ 面向连接（虚连接，并不是实际的物理连接）的传输层协议，在两个进程之间建立的端口之间的连接

+ 只能是点对点的

+ 可靠有序，不丢失不重复

+ 提供全双工通信，两端可以同时发送和接收数据，两端都会有发送缓存和接收缓存

  + 发送缓存：准备发送的数据和已发送但未收到确认的数据
  + 接收缓存：按序到达但尚未被接收应用程序读取的数据和不按序到达的数据，只有排好顺序后才可以被接收

+ 面向字节流

  TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流

#### TCP报文段首部格式

+ 序号seq：在一个TCP连接中传送的字节流中的每个字节都按顺序编号，本字段表示本报文段发送数据的第一个字节的序号
+ 确认号ack：期望收到对方下一个报文段的第一个数据字节的序号，若确认好为N，说明到序号N-1为止的所有数据都已正确收到

+ 数据偏移（首部长度）：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位

  因为数据偏移是4个字节，所以如果是1111的话，那么就是表示为15*4B，所以首部长度为60B，又因为TCP有20B的固定首部

  因此选项和填充字段占据40B，知道了首部长度，也就可以知道TCP报文段中从哪里开始是实际的数据部分

+ 紧急位URG：URG为1时，表明此报文段有紧急数据，是高优先级的，应该尽快传送，不用在缓存中排队，配合紧急指针字段使用

  URG=1可以让报文段不用在TCP缓存中等待，优先发送

+ 确认为ACK

+ 推送位PSH：PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付

  与URG不同，PSH是在接收方的统一处理，PSH=1表示该报文段应尽快交付给上层的进程

+ 复位RST：RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后重新建立传输连接

+ 同步为SYN：SYN=1时，表明是一个连接请求或接受报文

+ 终止位FIN：FIN=1时，表明此报文段发送方数据已发完，要求释放连接

+ 窗口：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量

  16位，0-2^16-1，根据接收方窗口大小，限制发送方窗口大小，如果发送方发送确认号ack=701，窗口大小为1000；那么接收方只能容纳1000字节，因此是701-1700

+ 校验和：检验首部和数据，检验时要加上12B伪首部，第四个字段为6

+ 紧急指针：URG=1时才有意义，指出本报文段中紧急数据的字节数

+ 选项：最大报文段长度MSS、窗口扩大、时间戳、选择确认

+ 填充：如果选项长度不是4B的整数倍，就需要对头部进行填充，因为上面说过首部长度的单位是4B

#### TCP连接管理

> TCP面向连接建立点对点的通信，全双工通信，既可以接收也可以发送

+ 建立连接
+ 传输数据
+ 释放连接

主动发起连接建立的应用进程叫做客户，被动等待连接建立的应用进程叫做服务器

**三次握手**

> + 客户端发送连接请求报文段，无应用层数据
>
>   SYN=1，一个随机生成的seq序列号seq=x
>
> + 服务器端为该TCP连接分配发送和接收缓存，并向客户端返回确认报文段，允许连接，无应用层数据
>
>   SYN=1，ACK=1，一个随机生产段seq序列号seq=y，ack=x+1，这里注意ack是期待对方发送的下一个报文段的起始位置，也就是对方上次发送的报文段的序列号seq+1
>
> + 客户端为该TCP连接分配缓存和比那里，并向服务器端返回确认的确认，可以携带数据
>
>   SYN=0，ACK=1，seq=x+1，ack=y+1

**SYN泛洪攻击**

> 大量半连接状态的TCP连接
>
> 解决：SYN cookie

**四次挥手**

> 因为TCP是全双工通信，因此任一方都可以释放连接
>
> + 客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接
>
>   FIN=1，seq=u，u取决于服务端发送的上一个报文段序列号
>
> + 服务端回送一个确认报文段，客户到服务器这个方向的连接释放，客户端处于半关闭状态
>
>   ACK=1，seq=v，ack=u+1，v同u
>
> + 服务器端发送完数据后，发出连接释放的报文段，主动关闭TCP连接
>
>   FIN=1，ACK=1，seq=w，w也取决于上一个报文段序列号，ack=u+1，因为这个过程中客户端并没有发送报文段过来，因此期待的报文段序列号不会改变
>
> + 客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭
>
>   因为如果服务端在发送确认报文段后没有收到客户端的确认ACK，那么就会重新发送确认报文段，客户端发送ACK的时间和服务端重新发送ACK的时间加起来就是2MSL。也就是说，如果在2MSL时间内，客户端没有收到服务端的重传ACK，就会关闭连接
>
>   如果不等待2MSL，会导致服务端一直收不到客户端的确认ACK，因此服务端会一直重发ACK确认报文段，同样也无法释放连接

#### TCP可靠传输

> 可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一样
>
> 虽然TCP是面向字节流的，但是TCP发送时会把多个字节组成一个报文段发送，报文段的序列号为第一个字节的序列号（每个字节都有以一个序列号）































































