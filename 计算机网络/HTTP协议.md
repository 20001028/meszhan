# HTTP总结

### HTTP1.1

#### 缺点

> + 队头阻塞
>
>   HTTP1.1虽然支持管线化pipelining技术一次发送一组连续的请求而不用等待返回后再发送请求，可以避免因为频繁建立和关闭连接带来的问题
>
>   但是它只能按照发送的顺序依次的接收响应。在请求的应答过程中，如果当前队头的请求应答出现状况，比如网络受阻或响应数据过大等情况，它就会阻塞住后面的所有请求应答
>
>   为了防止队头阻塞的问题，主流浏览器都会为同站开启6-8个连接，通过各个连接发送请求，这样可以避免某个连接阻塞带来的问题
>
>   但是还是无法避免队头阻塞
>
> + TCP连接数限制
>
>   对于同一个域名，浏览器最多只能同时创建6-8个连接。为了解决数量限制，对资源进行分域，放在不同域名下，针对不同域名创建连接和请求。但是每个TCP连接都需要经过DNS查询、三次握手和慢启动并占用额外的内存。
>
> + 臃肿的headers
>
>   虽然HTTP1中可以压缩请求内容，但是headers却无法压缩
>
> + 明文传输

### HTTP2

#### 二进制分帧

> 帧时数据传输的最小单位，用二进制代替明文擦婚书，将报文message划分为frame
>
> + strict-transport-security：max-age=63072000;includeSubdomains字段是服务器开启HSTS策略，让浏览器强制使用HTTPS进行通信，减少重定向造成的额外请求和会话劫持风险
> + 服务器开启 HSTS 的方法是: 以 nginx 为例，在相应站点的 server 模块中添加 `add_header Strict-Transport-Security "max-age=63072000; includeSubdomains" always;` 即可
> + 在 HSTS 有效期内且 TLS 证书仍有效，浏览器访问 blog.wangriyu.wang 会自动加上 https:// ，而不需要做一次查询重定向到 https

#### 多路复用

> 在一个TCP连接上，可以向对方不断发送帧，每帧的stream identifier标明这个帧属于哪个stream（HTTP采用流传输，HTTPS采用报文）。接收端在接收到最后一个frame后，根据标识符拼接每个流的frame组成一整块数据
>
> 把HTTP1.1的每个请求都当作一个流，多个请求变成多个流，请求响应数据分成多个frame，不同流中的frame交错的发送给对方
>
> 流的概念实现了单连接上多个请求-响应并行，解决了线头阻塞问题，减少了TCP连接数量和TCP连接慢启动问题、
>
> HTTP2对于同一域名只需要创建一个连接，不需要同HTTP1.1一样创建6-8个连接

#### 服务端推送

> 浏览器发送一个请求，服务器主动向浏览器推送与这个请求有关的资源
>
> Server Push主要针对资源内联做优化
>
> + 客户端可以缓存推送的资源
> + 客户端可以拒绝、
> + 推送资源可以由不同页面共享
> + 服务器可以按照优先级推送

#### Header压缩：HPACK















































