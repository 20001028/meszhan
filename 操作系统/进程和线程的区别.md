# 进程管理

https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md

### 进程与线程

#### 进程

进程时资源分配的基本单位，PCB进程控制块（Process Control Block）描述了进程的基本信息和运行状态，创建进程和撤销进程都是对PCB的操作。进程之间可以并发执行，相互独立。

#### 线程

线程是独立调度的基本单位。一个进程可以有多个线程，共享进程资源。

比如QQ和浏览器时两个进程，浏览器进程中有很多线程，例如请求线程、事件响应线程和渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接发起请求的同时还可以处理用户响应的其他事件。

#### 区别

+ 拥有的资源：进程会被分配资源，但是线程不会有自己的资源，只可以访问进程的资源

+ 调度：线程是调度的基本单位，线程的切换不会引起进程的切换，但是切换到另一个进程的线程会引起进程切换

+ 系统开销：由于创建或撤销进程时，系统都要分配资源，比如内存或IO等。付出的开销远大于创建或撤销线程的开销。

  在进行进程切换时，涉及当前执行进程CPU环境也就是上下文的保存以及新调度进程上下文的设置，而线程切换只需保存和设置少量的寄存器内容，开销很小

+ 通信：线程可以通过共享内存通信，进程之间通信需要IPC

### 进程状态的切换

+ 就绪状态：ready，等待被调度
+ 运行状态：running
+ 阻塞状态：waiting，等待资源

> 只有就绪状态和运行状态可以相互切换，其他都只能单向转换。就绪状态的进程通过调度算法从而获得CPU时间，转为运行状态；而运行状态的进程在分配给它的CPU时间片用完之后就会转为就绪状态，等待下一次调度。
>
> 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU时间，因为CPU时间隶属于调度的问题

<img src="https://camo.githubusercontent.com/0398c2bace5b1b0695f5a34f6cfedf6e358db565408abc83dd161de71d3bfec8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50726f6365737353746174652e706e67" style="zoom:50%;" />

### 进程调度算法

#### 批处理系统

> 批处理系统没有太多的用户操作，调度算法的目标是保证吞吐量（单位时间内处理的作业数量）和周转时间（从提交到终止）

**先来先服务FCFS**

> 非抢占式调度，按照请求顺序进行调度
>
> 有利于长作业，但是不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业有需要执行很长时间，造成短作业等待时间过长

**短作业优先SJF**

> 非抢占式的调度算法，按估计运行时间最短的顺序进行调度
>
> 长作业会一直得不到执行，一直等待短作业执行完毕，如果一直有短作业到来

**最短剩余时间SRTN**

> 抢占式，按剩余运行时间的顺序进行调度。
>
> 在一个新的作业到达时，将当前作业的运行时间与当前进程的剩余时间作比较，如果新的进程需要的时间更少，挂起当前进程，运行新的进程，否则新的进程等待

#### 交互式系统

交互式系统有大量的用户交互操作，调度算法的目标是快速进行响应

**时间片轮转**

> 将所有就绪进程按照先来先服务的顺序排成一个队列，每次调度的时候把CPU时间分配给队首进程，进程可以执行一个时间片。
>
> 当时间片用完时，由计时器发出中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程
>
> 时间片轮转算法的效率和时间片大小有关：
>
> + 如果时间片过小，会导致频繁的切换进程，但是进程状态保存和载入都需要花费时间
> + 如果过长，无法保证一些进程的实时性

![](https://camo.githubusercontent.com/a87daa8201015ff54a213d9ea95c1e49e7eec447938c441dd0247e80b18eaa05/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)

**优先级调度**

> 为每个进程分配一个优先级，按优先级进行调度
>
> 为了防止低优先级的进程永远得不到调度，可以随时间增大等待进程的优先级

**多级反馈队列**

> 对于需要执行很多时间片的进程来说，如果采用时间轮转算法，需要执行很多次
>
> 多级队列对于需要执行很多时间片的进程来说，设置了多个队列，每个队列的时间片的大小都不同，一般后面的时间片都会更大，这样才能减少时间片的数量
>
> 进程在第一个队列如果没有执行完成，就会被移入下一个时间片更大的队列中
>
> 每一个队列的优先权也不同，最上面的优先权最高（时间片越小），只有在上一层队列没有进程在排队，才能调度当前队列上的进程

![](https://camo.githubusercontent.com/c20fd7a3268ebc4ef0bce390344de2c5358392ecef2413d849c3095e21047980/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67)

#### 实时系统

> 实时系统要求一个请求在一个确定时间内得到响应
>
> 实时系统又分为硬实时和软实时，前者必须满足绝对的截止时间，后者是一个可以容忍一定的超时

### 进程同步

#### 临界区

对临界资源进行访问的那段代码称为临界区

为了互斥访问临界资源，每个进程在进入临界区之前，需要进程检查

#### 同步与互斥

+ 同步：多个进程因为合作之间的直接制约关系，使得进程有一定的先后执行关系
+ 互斥：多个进程在同一时刻只有一个进程能进入临界区

#### 信号量

信号量是一个整型变量，可以执行down和up操作，也就是常见的P和V操作

#### 管程

### 经典同步问题

#### 哲学家问题

#### 读者-写者问题

### 进程通信

为了达到进程同步的目的，需要让进程进行通信

#### 管道

管道是通过pipe函数创建的，fd[0]用于读，fd[1]用于写

+ 只支持半双工通信（单向交替传输）
+ 只能在父子进程或者兄弟进程使用

#### FIFO

命名管道，去除了管道只能在父子进程中使用的限制

FIFO常用于客户-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据

<img src="https://camo.githubusercontent.com/8c4dd36cf4d1509b9c3ae0500085617fee811f7a83602a71e64769753b66b66b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32616335306238312d643932612d343430312d623965632d6632313133656363333037362e706e67" style="zoom:80%;" />



#### 消息队列

优点：

+ 消息队列可以独立于读写进程存在，从而避免FIFO中同步管道打开和关闭时可能产生的困难
+ 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法
+ 读进程可以根据消息类型有选择的接收信息，而不像FIFO只能默认的接收

#### 信号量

信号量是一个计数器，用于为多个进程提供对共享数据对象的访问

#### 共享存储

允许多个进程共享一个给定的存储区，因为数据不需要在进程之间通信，所以是最快的一种IPC

需要使用信号量同步对共享存储的访问

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存

#### 套接字

可用于不同机器之间的进程通信



























