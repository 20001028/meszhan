# 前端缓存

https://juejin.cn/post/6844903747357769742

### 前言

> + 了解强缓存
> + 了解协商缓存
> + 了解它们的区别：使用本地缓存时是否需要向服务器验证本地缓存是否依旧有效，确定是否使用本地缓存

### 缓存位置

> HTTP headers中的字段都属于disk cache，缓存位置优先级：
>
> + Service Worker
> + Memory Cache
> + Disk Cache
> + 网络请求

#### Memory Cache

> 内存中的缓存，先读内存，再读硬盘
>
> 几乎所有的网络请求资源都会被浏览器自动加入到memory cache中，因为数量很大，会占用浏览器内存，它只能是短期存储
>
> 在浏览器TAB关闭后memory cache就会失效（也有可能未关闭就失效）

**preloader**

**preload**

> memory cache保证一个页面如果有多个相同的请求都只会被请求最多一次
>
> 在匹配缓存时，除了匹配完全相同的URL外，还会比对他们的类型，CORS的域名规则。作为一个script类型被缓存的资源，不能用在image类型的请求中，即便src相等
>
> 在从memory cache获取缓存内容时，浏览器会忽视HTTP头部配置。比如几个相同src的图片，即使设置了不缓存，依然可以从memory cache中读取。因为memory cache只是短期使用大部分情况下只能浏览一次。max-age=0在语义上被解读为不要在下次浏览时使用，所以与memory cache不冲突。
>
> 如果确实不想让资源进入缓存，应该在cache-control中使员工no-store，这样memory cache也不会存储。

#### disk cache

> 也就是HTTP Cache，是存储在硬盘上的存储，持久存储，实际存在于文件系统中，允许相同资源在跨回话跨站点使用。
>
> disk cache严格根据HTTP头信息中各类字段判定哪些资源可以进行缓存，哪些不可以，哪些可用，哪些需要重新请求。命中后会从硬盘读取资源

#### Service Worker

> 上面的缓存策略，都是由浏览器内部判断和执行的，我们只能设置响应头的字段来控制
>
> Service Worker能够操作的缓存时有别于浏览器内部的memory cache或者disk cache。这个缓存可以在Application --> Cache Storage中找到，除了位置不同外，这个缓存是永久的，不会因为关闭tab或浏览器而消失。清除只能通过手动调用cache.delete(resource)或容量超过限制被浏览器清空
>
> 如果Service Worker没有能命中缓存，一般会使用fetch方法继续获取，这时浏览器会去memory cache或disk cache继续找缓存。
>
> 经过Service Worker的fetch中获取的资源，即使没有命中Service Worker缓存，甚至走了实际的网络请求，也会标注为from ServiceWorker

#### 请求网络

> 如果都没有找到缓存，就会正式的发送网络请求
>
> + 根据Service Worker的handler绝对是否存入Cache Storage
> + 根据HTTP头部字段决定是否存入disk cache
> + memory cache保存一份资源的引用

### 强缓存

> 依据：硬盘内的资源是否超出某个时间或时间段，不关心服务端资源是否发生改变或更新
>
> 缺点：可能导致记载的文件不是服务端最新的内容

#### 字段

**Cache-Control：HTTP1.1**，优先级高于Expires

> 一般设为：public, max-age=xxx，表示在xxx秒内再次访问该资源，将使用本地缓存，不再向服务器发起请求
>
> 从而衍生了一种问题：如果在xxx秒内，服务器上的资源发生更新，怎么办？

**Expires：HTTP1.0**

> 一个绝对的过期时间（GMT格式的时间字符串），这个时间之前都不需要再次请求，
>
> 缺点：
>
> + 客户端时间与服务器时间不同步
> + 写法严格

### 协商缓存

> 每次都要向服务器验证一下缓存的有效性，但是它违背了缓存的目的（减少请求，尽可能的使用本地资源，减轻服务器压力）
>
> 方法：在更新版本时，修改静态资源的路径，浏览器就会把它当成一个新的资源去请求，不存在缓存的问题

**Last-Modified和If-Modified-Since**

> 在第一次请求资源时，服务器将资源传递给浏览器时，将资源最后修改的时间以GMT的形式发送给浏览器
>
> 再次请求时，会将该信息附带在请求头中发送给服务器检查，如果时间一致，返回304和空响应体
>
> 缺点：
>
> + 无法获取精确的修改时间，即文件修改的精度小于秒
> + 文件修改时间改变，但内容不变

**ETag和If-None-Match**

> ETag是上一次加载资源时，服务器返回的响应头字段，是对资源的唯一标识，只要资源发生变化，ETag都会重新生成
>
> 浏览器在下一次加载资源向服务器发送请求时，会将上一次的ETag放到请求头中，服务器比较是否一致，判断资源是否被修改过
>
> 如果无法匹配，返回200+新的资源，如果一致，返回304然后使用本地缓存

**优先级**

> + 在精度上，ETag优于Last-Modified，Last-Modified的时间单位是秒，因此在秒之内的修改不会被检测到
>
>   如果是负载均衡的服务器，服务器之间的时间也有可能不一致
>
> + 性能上，ETag不如Last-Modified，后者只需要记录时间，而ETag需要服务器通过算法计算hash值
>
> + 真正的缓存优先级上，服务器会优先校验ETag

**用户行为**

> + 地址栏访问和链接跳转都是用户正常行为，会触发浏览器缓存
> + F5刷新，浏览器设置max-age=0，跳过强缓存，之间进行协商缓存
> + Ctrl+F5，跳过所有缓存，直接从服务器获取资源

#### webpack中的缓存

> 为文件名带上hash值

```javascript
entry:{
    main: path.join(__dirname,'./main.js'),
    vendor: ['react', 'antd']
},
output:{
    path:path.join(__dirname,'./dist'),
    publicPath: '/dist/',
    filname: 'bundle.[chunkhash].js'
}
```

### 哈希中的不同哈希

> + hash：与整个项目构建有关，构建生成都文件hash值相同，只要项目中有文件修改，整个项目构建的hash值都会更改
> + chunkhash：根据不同入口文件进行依赖文件解析，构建对应的chunk，生成对应的hash，也就是一个chunk一个hash
> + contenthash：由文件内容产生hash，内容不同产生的contenthash不同
>
> 在实际应用中，一般把项目中的css抽离出对应的css文件加以引用，如果使用chunkhansh，改变css代码后，也会改变js文件的hash值，这就是我们为什么要使用contenthash

### ETag与Last-Modified的比较

> 在Express中，使用fresh包判断是否是最新的资源

```javascript
function fresh (reqHeaders, resHeaders) {
  // fields
  var modifiedSince = reqHeaders['if-modified-since']
  var noneMatch = reqHeaders['if-none-match']

  // unconditional request
  if (!modifiedSince && !noneMatch) {
    return false
  }

  // Always return stale when Cache-Control: no-cache
  // to support end-to-end reload requests
  // https://tools.ietf.org/html/rfc2616#section-14.9.4
  var cacheControl = reqHeaders['cache-control']
  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
    return false
  }

  // if-none-match
  if (noneMatch && noneMatch !== '*') {
    var etag = resHeaders['etag']

    if (!etag) {
      return false
    }

    var etagStale = true
    var matches = parseTokenList(noneMatch)
    for (var i = 0; i < matches.length; i++) {
      var match = matches[i]
      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
        etagStale = false
        break
      }
    }

    if (etagStale) {
      return false
    }
  }

  // if-modified-since
  if (modifiedSince) {
    var lastModified = resHeaders['last-modified']
    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))

    if (modifiedStale) {
      return false
    }
  }

  return true
}
```

> 如果不是强制刷新（任何缓存都不会起作用），而且在请求头中带上了if-modified-since（Last-Modified）和if-none-match（ETag）
>
> 先判断ETag，再判断Last-Modified

### 后端配置缓存

#### 强缓存

```
res.setHeader('Cache-Control', 'public, max-age=xxx');
```

#### 协商缓存

```
res.setHeader('Cache-Control', 'public, max-age=0');
res.setHeader('Last-Modified', xxx);
res.setHeader('ETag', xxx);
```

### 缓存的应用模式

#### 不常变化的资源

> 给Cache-Control配置一个很大的max-age，这样浏览器之后请求相同的URL会命中强缓存
>
> 为了解决更新的问题，需要在文件名或路径中添加hash，版本号等动态字符，从而更改引用URL，让之前的强缓存失效（不再被使用）

#### 经常变化的资源

> 不单单是指静态资源，也可能是网页资源，比如博客文章。这些资源虽然URL不能变化，但是内容经常变化。
>
> 设置Cache-Control：no-cache来使浏览器每次请求都必须找服务器验证资源是否有效。

### 总结

> 在做前端缓存时，尽可能设置长时间的强缓存，通过文件名+hash来做版本更新。
>
> 在代码分包时，将一些不常改变的公共库独立打包（vendor），可以更持久的缓存

### Q & A

#### max-age=0与no-cache是否等价

> 从字面意思来说，max-age到期是应该重新验证，而no-cache是必须重新验证，实际情况中行为大致一致
>
> max-age=0+must-revalidate与no-cache完全等价









































