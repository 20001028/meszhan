# 同源策略和跨域

https://juejin.cn/post/6844903767226351623

### 同源策略

> 同源策略是一种约定，是浏览器最核心和最基本的安全功能，如果缺少了同源策略，浏览器将很容易收到XSS和CSRF攻击
>
> 同源策略：同协议、域名、端口

#### 限制内容

+ Cookie、LocalStorage、IndexedDB
+ DOM节点
+ AJAX请求

#### 默认允许跨域

+ img的src
+ script的src
+ link的href

#### 常见的跨域场景

> + 如果是协议和端口造成的跨域问题，前端无法解决
> + 在跨域问题上，仅仅是通过URL首部来识别而不会根据域名对应的IP地址是否相同来判断
>
> 跨域并不是请求发不出去，请求依然能够照常发送，服务端在收到请求后正常返回结果，但是结果会被浏览器拦截
>
> 为什么表单可以发起跨域请求，Ajax不可以？
>
> 因为跨域是为了阻止用户读取另一个域名下的内容，Ajax可以获取响应，浏览器任务不安全，所以进行拦截。但是表单并不会获取新的内容，只是为了提交数据而已，所以跨域并不能完全阻止CSRF，因为请求已经发出去了。

### 跨域解决方案

#### JSONP

> 原理：
>
> ​	利用script标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的JSON数据，但是要求对方的服务器做支持
>
> 和AJAX对比：
>
> ​	JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务端获取数据的方式，但AJAX是同源策略，JSONP属于非同源（跨域请求）
>
> JSONP优缺点：
>
> ​	简单兼容性好，用于解决主流浏览器的跨域数据访问问题
>
> ​	但是仅支持GET方法，不安全可能会受到XSS攻击

#### CORS

> 需要浏览器和后端支持
>
> 因为浏览器会自动进行CORS通信，实现CORS通信的关键是后端配置。只要后端实现了CORS，前端也就实现了跨域
>
> 服务端设置Access-Control-Allow-Origin可以开启CORS，该属性表示哪些域名可以访问资源，如果设置*通配符表示所有网站都可以访问
>
> CORS发送请求时有两种请求：简单请求和复杂请求

**简单请求**

> 条件：
>
> + GET/HEAD/POST
> + Content-Type：text/plain、multipart/form-data、application/x-www-form-urlencoded

#### 复杂请求

> 不是简单请求的请求
>
> 复杂的CORS请求，会在正式请求之前，增加一次查询请求，即预检请求，OPTION方法，通过该请求了解服务端是否允许跨域

```javascript
// 允许哪个方法访问我
res.setHeader('Access-Control-Allow-Methods', 'PUT')
// 预检的存活时间
res.setHeader('Access-Control-Max-Age', 6)
// OPTIONS请求不做任何处理
if (req.method === 'OPTIONS') {
  res.end() 
}
// 定义后台返回的内容
app.put('/getData', function(req, res) {
  console.log(req.headers)
  res.end('我不爱你')
})
```

#### postMessage

> postMessage时HTML5中的API，是为数不多可以跨域操作的window属性之一
>
> 它可以解决以下问题：
>
> + 页面和其打开的新窗口的数据传递
> + 多窗口之间消息传递
> + 页面与嵌套的iframe传递
>
> postMessage方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文档、多窗口、跨域消息传递

```javascript
/*
	* message:要发送到其他window的数据
	* targetOrigin：通过窗口的origin属性来指定哪些窗口能接受到消息事件，可以是*通配符
	* transfer：与message同时发送到Transferable对象，对象的所有权被转移给接收方
*/
window.postMessage(message, targetOrigin, [transfer]);
```

#### Node中间件代理

>  同源策略是浏览器需要遵循的标准，但是服务器向服务器请求无需遵循
>
> 代理过程：
>
> + 浏览器向代理服务器发送请求
> + 代理服务器转发给服务器
> + 服务器响应给代理服务器
> + 代理服务器转发响应给浏览器

#### Nginx反向代理

#### window,name+iframe

> Window.name属性的独特之处：name值在不同的页面加载后依旧存在，并且支持非常长的name值
>
> 通过iframe的src属性由不同域传递到同域，跨域数据从iframe的window.name从不同域传递到同域名

#### location.hash+iframe

> a.html要与c.html跨域相互通信，通过中间页b.html实现，三个页面不同域之间利用iframe的location.hash传值，相同域之间接受访问通信

#### document.domain+iframe

> 只能是子域名相同，比如a.test.com和b.test.com，只需要给页面添加documnt.domain='test.com'表示🎧域名相同实现跨域
>
> 原理：两个页面都通过js强制document.domain为基础主域，实现同域































